---
title: State-space implementations of digital IIR filters
subtitle: Lab 9, SDP
format:
  html: default
  pdf: default
  ipynb: default

toc: true
number-depth: 2
number-sections: true

jupyter: python3
execute:
  freeze: true
  eval: false
---

\newcommand*{\underuparrow}[1]{\ensuremath{\underset{\uparrow}{#1}}}

## Objective

The students should become familiar with *state-space* type realization structure
used for implementing IIR filters.

## Theoretical notions

### State-Space Type I implementation

![State-Space Type I equations, for an IIR system of order 3](img/IIR_StateSpaceType1_Eqs.png){#fig-eqstip1 width=70%}

![Schematic according to the equations (type I, order 3)](img/IIR_StateSpaceType1_Fig.png){#fig-figtip1 width=70%}

The equations defining the state-space type I filter realization are given in
@fig-eqstip1, for a IIR system of order 3.

The schematic according to these equation is in @fig-figtip1.

### State-Space Type II implementation

![State-Space Type II equations, for an IIR system of order 3](img/IIR_StateSpaceType2_Eqs.png){#fig-eqstip2 width=60%}

![Schematic according to the equations (type II, order 3)](img/IIR_StateSpaceType2_Fig.png){#fig-figtip2 width=70%}

The equations defining the state-space type II filter realization are given in
@fig-eqstip2, for a IIR system of order 3.

The schematic according to these equation is in @fig-figtip2.

### General equations

![General state-space equations](img/IIR_StateSpace_EqsGeneral.png){#fig-eqsgen width=35%}

![Definition of the terms for type I](img/IIR_StateSpaceType1_EqsGeneral.png){#fig-eqsgentip1 width=70%}

![Definition of the terms for type II](img/IIR_StateSpaceType2_EqsGeneral.png){#fig-eqsgentip2 width=70%}

In the general case, there are always the two equations in @fig-eqsgen:

- the **state equation**: produces the next state $\mathbf{v}[n+1]$ depending on the current state $\mathbf{v}[n]$ and current input $x[n]$;
- the **output equation**: produces the current output $\mathbf{y}[n]$ depending on the current state $\mathbf{v}[n]$ and current input $x[n]$.

The definition of the general terms, according to type I or type II, is given in @fig-eqsgentip1 È™i @fig-eqsgentip2.

## Theoretical exercises

1. Consider the IIR system with the system function
	$$H(z) = \frac{1 + 2z^{-1} + 3 z^{-2} + 2 z^{-3}}{1 + 0.9z^{-1} + 0.8 z^{-2} + 0.5 z^{-3}}$$

	a. Write the equations and draw the type I and type II state-space implementations of this system
    b. Compute the first 5 values of the step response, considering the initial conditions
	$v[0]=
	\begin{bmatrix}
	0 \\
	0 \\
	1
	\end{bmatrix}$

2. Consider the system with the following state-space equations:

	$$v[n+1] =
	\begin{bmatrix}
	0     & 1 \\
	-0.81 & 1
	\end{bmatrix}
	v[n] +
	\begin{bmatrix}
	0 \\
	1
	\end{bmatrix}
	x[n]
	$$
	$$y[n] =
	\begin{bmatrix}
	- 1.81 & 1
	\end{bmatrix}
	+ x[n]
	$$

	a. Find the system function of this system
	b. Compute the first 5 values of the step response, considering the initial conditions
	$v[0]=
	\begin{bmatrix}
	0 \\
	1
	\end{bmatrix}$
	c. Draw the the type I and type II state-space implementations of this system, as well as the direct form II implementation


## Practical exercises

1. In the Matlab environment, use the `fdatool` tool to design one of the following filters:

    a. A low-pass filter, IIR, order 4, elliptic type, with cutoff frequency of 5kHz for a sampling frequency of 44.1 kHZ;
    a. A high-pass filter, IIR, order 4, elliptic type, with cutoff frequency of 1kHz for a sampling frequency of 44.1 kHZ;
    a. A band-pass filter, IIR, order 4, elliptic type, with pass-band between 700Hz and 4kHz for a sampling frequency of 44.1 kHZ.

    Export the coefficients to Matlab's Workspace.

2. Fill in the following code template to perform temporal filtering of a video sequence, using the filter designed above.
   Test the function on the video sequence `veh_small.mp4`.

   Use the state-space type I equations, but extend them to a system of order 4.

   ```
   v = VideoReader('videofile.mp4');

   % Read all the frames from the video, one frame at a time.

   while hasFrame(v)
    frame = readFrame(v);

	% Do the processing heres

	% Output equation
	y = ...

	% State equation
	v1_next = ...
	v2_next = ...
	v3_next = ...
	v4_next = ...

	% Update for next iteration
	v1 = v1_next;
	v2 = v2_next;
	v3 = v3_next;
	v4 = v4_next;

   end
   ```

4. Implement a function `filter_spst(b, a, x)` which filters a signal `x` with
the filter defined by the coefficients `b` and `a`. Implementation shall follow the type I state-space equations.

5. Test the function written above with the coefficients designed at step 3, by filtering a sample audio signal.


## Final questions

1. TBD
